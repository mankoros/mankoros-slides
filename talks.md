# 0

> 封面

各位评委老师大家好，我们是来自哈尔滨工业大学 (深圳) 的参赛队伍，MankorOS, 我是队长满洋。今天我来介绍一下我们内核的特色与实现。

# 1

> 总体介绍

我们的内核基于 rust 开发，在一万六千行代码内实现了 77 条系统调用与完全异步的调度方式，能支持决赛第一阶段除去网络之外的测试，还能运行一个名为 cemu 的类 qemu 模拟器。我们的内核有一个最大的特点：它能在不重新编译的情况下，以同一份二进制在不同平台启动，比如 QEMU 和 VisionFive V2. 为此，我们实现了一些特殊的功能。 

# 2

> 宗旨，一句话居中

在开发过程中，我们总是在思考一个问题：测试程序真的就代表一切吗？也许测试程序是最客观也是最直观的评判标准，它直接反映到比赛分数之上，可那些真正的操作系统应该具有，却不被测试程序所反映的部分，它们就真的不重要吗？我们并不这样觉得。于是我们做出了一个大胆的决定：我们要做一些往年参赛队伍没有做过的功能，当然，它必须是有用的功能，而且是工业操作系统所需要的功能。

# 3

> 下边四个功能的目录

那么什么功能是没有队伍做过的呢？我们进行了一些调查，最后决定实现这些功能：

一是任意地址的内核装载，二是基于设备树的灵活设备发现，三是对外部中断的支持，最后是异步协作式内核调度，以及一个比较有趣的套娃尝试：能不能在我们的操作系统上通过模拟器运行 Linux？

# 4

> 任意地址内核装载 - 首页

首先是任意地址的内核装载。大家知道，在内核接管 CPU 到打开地址翻译前，有一个短暂但重要的 "空档期", 在这段过程中内核需要将自己**装载**起来，放到链接时决定的特定地址空间范围中，使得内核能正常工作。在编写该部分代码时我们感到了一些困难，于是我们便非常好奇：其他人是怎么做的？

首先是作为教学 OS 标杆的 xv6, 它直接使用低地址空间作为内核占用的虚拟地址范围，于是在该阶段内核基本上不需要做任何事，只需要直接开启地址翻译即可。但这样做的问题是内核挤占了部分本来应该交给用户使用的地址空间，导致 xv6 无法支持大小较大的用户程序。 

其次是往届参赛队伍，他们都将内核二进制代码固定链接到一个特定的高位地址，并直接硬编码启动页表至内核数据段，随后直接使用汇编设置页表并打开地址翻译。这样做确实能正确实现地址翻译，但是，使用硬编码的话，对于不同的硬件，比如 qemu 和真实的开发板，便需要编译两份只有链接地址不同的内核二进制。而这显然是不够优雅的。

只能如此吗？显然不是，因为 Linux 就支持将内核装载任意 2M 对齐的地址，而无需重新编译。而内核地址空间随机化这种现代操作系统必备的安全设施也要求内核能被装载到任意地址上。既然它有用又没有人做过，我们一拍脑袋，便决定我们要做这个了。

# 5

> 任意地址内核装载 - 实现难点

事实证明，往届队伍没人实现这个特性是有原因的。内核的自我装载是系统启动过程中非常早期的阶段，此时各项外设包括串口都还没有被初始化，换句话说，这个模块将没有日志，只能 "摸黑" 调试：一旦失败，那就只有板子和上帝知道哪里出问题了。

而这个特性的实现又需要一些微妙晦涩的代码。首先，该阶段的代码中的跳转必须严格位置无关，因为在启动地址翻译前后，它将位于不同的虚拟地址中，但 rust 对位置无关代码的编译支持却并不完善; 其次，启动页表不能被硬编码到内核二进制中，必须现场计算与构造; 最后，启动页表的动态构造需要内存管理，可普通的内存管理需要我们打开地址翻译，这又成为了一个左脚踩右脚的经典难题。

不过好在，我们最后理顺了逻辑，顺利实现了这个特性。

# 6

> 任意地址内核装载 - 实现方法

TODO 太专业了，有空再写 (这里给 500 字左右 (1min30s))

# 7

> 基于设备树的灵活设备发现 - 首页

在实现完任意地址内核装载后，我们又发现了一个问题：不同平台上的设备显然是不同的，为了让同一份内核二进制能在不同平台上运行，我们还需要另一项特性：那就是灵活的设备发现与管理机制。

# 8

> 基于设备树的灵活设备发现 - 设备管理现状观察

同样的，我们首先去观察了一下往届参赛队伍的做法。由于它们本来就需要对不同平台重新编译内核，所以基本上它们都直接将设备信息硬编码到内核中，通过编译开关切换，只有 ArceOS 实现了简单的设备发现与管理。类似的，xv6 也是直接将设备信息硬编码到内核中，而 rCore 反而与 ArceOS 类似，实现了简单的设备发现与管理机制。

事实上，可以纳入到设备管理机制上的设备很多，常见的诸如 PLL 模块，电源管理模块，UART 串口，SD 卡控制器等等都可以视作普通的设备; 就连 CPU 和 PLIC 可以视作两种特殊设备来纳入管理。因此我们决定实现一个通用的设备发现与管理机制。

# 9

> 基于设备树的灵活设备发现 - 实现

实现上，我们利用 rust 的 trait 机制将设备抽象为一个带虚表的结构体，它们必须实现两个接口 `probe` 和 `interrupt_handler`, 分别用于设备发现和中断处理。那么设备到底该如何发现呢？我们采用了业界通用的设备树机制，手写了一份设备树解析的代码，这样我们便可以直接复用产商向 linux 上游提交的 patch 中的设备树信息了，实现了与 linux 的接轨。

而中断处理方面，我们使用一个 BTreeMap 维护中断号与设备的映射以将不同的中断传递给具体设备处理。这样，我们便实现了一个基于设备树的通用又灵活的设备发现与管理机制。只剩下了一个问题：真的有这么多中断吗？

# 10

> 外部中断支持 - 首页

<!-- 感觉不用说话，直接停顿一下就好了 -->

# 11

> 外部中断支持 - 中断现状观察

根据我们的观察，大部分参赛队伍都几乎不处理外部中断，少部分队伍只处理有限的几个外部中断。而 xv6 也仅仅只是处理了串口与 virtio 外部中断。为什么会这样呢？我们进行了一些分析。

# 12

> 外部中断支持 - 原因分析

首先是从比赛来看，比赛允许内核基于 OpenSBI, 而它提供了一个 debug console 的功能可以直接用于实现串口 IO, 这就解决了比赛中对外设 IO 的几乎全部的需求。再加上比赛中对其他外设的处理没有要求，所以大家对该部分的实现兴趣不大。

其次，目前很多硬件产商都不原因公开相关手册。我们在实现这部分功能的时候，曾向板子产商询问相关信息，但产商并没有给我们任何的回复。再加上目前 riscv SoC 上中断处理部件的标准才刚刚 ratified, 之前的实现都是厂商各自为政，导致这部分实现非常繁琐。

最后，我们认为教学上的忽视也是原因之一。目前高校中组成原理一般聚焦于 CPU 核心开发，而缺少对核外 SoC 部件上的讲解，导致大家对该部分实现感到陌生，因而不愿意开发相关功能。

# 13

> 外部中断支持 - 实现 1

我们根据最近 ratified 的 RISC-V PLIC 标准实现了中断处理。

<!-- TODO: 介绍一下这个标准 -->

# 14

> 外部中断支持 - 实现 2

TODO: 这图看不太懂，待会再写 (300 字左右，1min)

<!-- TODO: 介绍一下在该标准中，外部中断大概是如何处理的 -->

# 15 

> 异步协作式内核调度 - 首页

既然我们支持了任意标准的外部中断，那么 SD 卡等 IO 设备的底层驱动便可以直接实现为基于中断的异步模式了。为了更好地利用我们前面对底层设备的支持，我们决定基于异步方式实现我们的整个内核。

# 16

> 异步协作式内核调度 - 原因

在 OS 竞赛中，异步内核已经不算十分新鲜的东西了，FTL-OS 等队伍均已实现了异步内核。对我们而言，采用异步的原因主要在于我们内核对底层设备中断的完善支持，它允许我们直接将底层 IO 实现为异步模式，为整个异步内核打下了基础。

在开发过程，我们逐渐体会到异步调度的优势。异步调度能充分利用 CPU 这一资源。就像当用户程序调用 IO 类系统调用时，内核一般会将 CPU 转交给其他进程一样; 当内核**本身**因为等待 IO 而不得不停顿时，异步调度器能直接让当前内核放弃对 CPU 的占用，基本上杜绝了内核中 CPU  "空转" 现象，这极大地加强了多路 IO 的性能表现。

最后，得益于 rust 对异步的良好支持，在整个内核开发过程中我们并没有遇到什么与异步相关的 bug, 内核的大部分代码编写难度几乎与同步内核相同。

# 17

> 异步协作式调度 - 实现要点

为了尽可能地提高我们内核的异步程度，我们基本上实现了所有能异步实现的地方。首先自然是我们一开始的目标：从驱动到 VFS 全链条完整的异步文件系统。任何不需要 CPU 参与的，要向底层设备请求的数据都会导致当前内核进程的休眠，从而极大地提升了 CPU 的利用率。

其次是异步的管道，只有在读取端读取了管道内容之后，写入端才会被唤醒执行，反之亦然，使得管道两端自然地根据数据产生速率得到了与之匹配的调度时间。

然后是内核中的异步睡眠锁与异步睡眠队列，它们有类似的需求："暂时放弃当前函数的执行，满足条件后再重新调度", 因此可以直接依托于内核的异步基础设施实现，相比同步内核，在代码实现上非常简洁。

最后，我们要指出，异步内核本身可以通过 "不断轮询，每次重新加入调度器末尾并放弃执行权，直到执行成功" 的方式模拟一切同步内核中的轮询等待方式，因此理论上是不存在任何同步内核能做而异步内核不能做的事情的。

# 18

> 异步协作式调度 - iozone 测试结果

得益于我们从底层到高层的全链条异步文件系统，以及我们采用的相对激进的缓存策略，我们的内核在 `iozone` 单项测试中得分位居第一，获得了将高达 38.9 分的成绩。

# 19

> 特色功能 - 首页

最后是我们一个有趣的小尝试：我们天天使用模拟器测试我们的内核，那么我们能不能在我们的内核中也跑一个模拟器呢？

# 20

> 特色功能 - GIF

<!-- 先不播放 -->

TODO

<!-- 播放 -->

TODO

# 21

> 总结

所以，这就是我们的内核，MankorOS, 一个能将自己装载到任意地址启动的内核，一个能灵活地读取设备树文件发现设备的内核，一个能接受任意 PLIC 标准外部中断的内核，一个自底向上决定要使用异步的内核，最终，一个做到了历年没有队伍做过的事的内核。

我们的答辩到此结束，请各位评委老师批评指正。

