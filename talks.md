# 1

> 封面

各位评委老师大家好, 我们是来自哈尔滨工业大学 (深圳) 的参赛队伍, MankorOS, 我是队长满洋. 今天我来介绍一下我们内核的特色与实现. 

<!-- 总体介绍直接放最后 -->

# 2

> 宗旨, 一句话居中

在开发过程中, 我们总是在思考一个问题: 测试程序真的就代表一切吗? 也许测试程序是最客观也是最直观的评判标准, 它直接反映到比赛分数之上, 可那些真正的操作系统应该具有, 却不被测试程序所反映的部分, 它们就真的不重要吗? 我们并不这样觉得. 于是我们做出了一个大胆的决定: 我们要做一些往年操作队伍没有做过的功能, 即使它并不是测试程序所必须的.

# 3

> 目录

那么什么功能是没有队伍做过的呢? 我们进行了一些调查, 最后决定实现这些功能:

一是启动阶段的内存管理, 二是基于设备树的灵活设备发现, 三是对外部中断的支持, 最后是异步协作式内核调度, 以及一个比较有趣的套娃尝试: 能不能在模拟器中跑模拟器?

# 4

> 启动阶段内存管理 - 首页

首先是启动阶段的内存管理. 大家知道, 在内核接管 CPU 到打开地址翻译前, 有一个短暂但重要的 "空档期", 在这段过程中内核需要将自己**装载**起来, 放到链接时决定的特定地址空间范围中, 使得内核中一些位置相关的跳转能正常工作. 在编写该部分代码时我们感到了一些困难, 于是我们便非常好奇: 其他人是怎么做的?

首先是作为教学 OS 标杆的 xv6, 它直接使用低地址空间作为内核占用的虚拟地址范围, 于是在该阶段内核基本上不需要做任何事, 只需要直接开启地址翻译即可. 但这样做的问题是内核抢占了部分本来应该交给用户使用的地址空间, 导致 xv6 无法支持大小较大的用户程序.  

其次是往届参赛队伍, 他们都将内核二进制代码固定链接到一个特定的高位地址, 并直接硬编码启动页表至内核数据段, 随后直接使用汇编设置页表并打开地址翻译. 这样做确实能正确实现地址翻译, 但是, 使用硬编码的话, 对于不同的硬件, 比如 qemu 和真实的开发板, 便需要编译两份只有链接地址不同的内核二进制. 而这显然是不够优雅的.

只能如此吗? 显然不是, 因为 linux 就支持将内核装载任意 2M 对齐的地址, 而无需重新编译. 而内核地址空间随机化这种现代操作系统必备的安全设施也要求内核能被装载到任意地址上. 既然它有用又没有人做过, 我们一拍脑袋, 便决定我们要做这个了.

# 5

> 启动阶段内存管理 - 实现难点

事实证明, 往届队伍没人实现这个特性是有原因的. 内核的自我装载是系统启动过程中非常早期的阶段, 此时各项外设包括串口都还没有被初始化, 换句话说, 这个模块将没有日志, 只能 "摸黑" 调试: 一旦失败, 那就只有板子和上帝知道哪里出问题了. 

而这个特性的实现又需要一些微妙晦涩的代码. 首先, 该阶段的代码中的跳转必须严格位置无关, 因为在启动地址翻译前后, 它将位于不同的虚拟地址中, 但 rust 对位置无关代码的编译支持却并不完善; 其次, 启动页表不能被硬编码到内核二进制中, 必须现场计算与构造; 最后, 启动页表的动态构造需要内存管理, 可普通的内存管理需要我们打开地址翻译, 这又成为了一个左脚踩右脚的经典难题. 

不过好在, 我们最后理顺了逻辑, 顺利实现了这个特性.

# 6

> 启动阶段内存管理 - 实现方法

